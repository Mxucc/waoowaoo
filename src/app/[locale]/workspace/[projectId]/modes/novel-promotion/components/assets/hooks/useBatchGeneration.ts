'use client'
import { logError as _ulogError } from '@/lib/logging/core'

/**
 * useBatchGeneration - æ‰¹é‡ç”Ÿæˆèµ„äº§å›¾ç‰‡
 * ä» AssetsStage.tsx æå–
 * 
 * ğŸ”¥ V6.5 é‡æ„ï¼šç›´æ¥è®¢é˜… useProjectAssetsï¼Œæ¶ˆé™¤ props drilling
 * ğŸ”¥ V6.6 é‡æ„ï¼šå†…éƒ¨ä½¿ç”¨ mutation hooksï¼Œç§»é™¤ onGenerateImage prop
 */

import { useState, useCallback, useMemo, useEffect } from 'react'
import { useTranslations } from 'next-intl'
import { CharacterAppearance } from '@/types/project'
import { useProjectAssets, useRefreshProjectAssets, useGenerateProjectCharacterImage, useGenerateProjectLocationImage, type Character } from '@/lib/query/hooks'
import { useWorkspaceProvider } from '../../../WorkspaceProvider'
import {
    createManualKeyBaseline,
    isAppearanceTaskRunning,
    shouldResolveManualKey,
    type ManualRegenerationBaseline,
} from './useBatchGeneration.helpers'

interface UseBatchGenerationProps {
    projectId: string
    // ğŸ”¥ V6.6ï¼šç§»é™¤ onGenerateImageï¼Œå†…éƒ¨ä½¿ç”¨ mutation hooks
    handleGenerateImage?: (type: 'character' | 'location', id: string, appearanceId?: string, openManualModal?: boolean) => Promise<void> | void
}

export function useBatchGeneration({
    projectId,
    handleGenerateImage: externalHandleGenerateImage
}: UseBatchGenerationProps) {
    const t = useTranslations('assets')
    const { manualAssetMode } = useWorkspaceProvider()
    // ğŸ”¥ ç›´æ¥è®¢é˜…ç¼“å­˜ - æ¶ˆé™¤ props drilling
    const { data: assets } = useProjectAssets(projectId)
    const characters = useMemo(() => assets?.characters ?? [], [assets?.characters])
    const locations = useMemo(() => assets?.locations ?? [], [assets?.locations])

    // ğŸ”¥ ä½¿ç”¨åˆ·æ–°å‡½æ•°
    const refreshAssets = useRefreshProjectAssets(projectId)

    // ğŸ”¥ V6.6ï¼šå†…éƒ¨ mutation hooks
    const generateCharacterImage = useGenerateProjectCharacterImage(projectId)
    const generateLocationImage = useGenerateProjectLocationImage(projectId)

    // ğŸ”¥ å†…éƒ¨å›¾ç‰‡ç”Ÿæˆå‡½æ•°
    const internalHandleGenerateImage = useCallback(async (type: 'character' | 'location', id: string, appearanceId?: string) => {
        if (type === 'character' && appearanceId) {
            await generateCharacterImage.mutateAsync({
                characterId: id,
                appearanceId,
                manualMode: manualAssetMode,
                openManualModal: false,
            })
        } else if (type === 'location') {
            await generateLocationImage.mutateAsync({
                locationId: id,
                imageIndex: 0,
                manualMode: manualAssetMode,
                openManualModal: false,
            })
        }
    }, [generateCharacterImage, generateLocationImage, manualAssetMode])

    // ä½¿ç”¨å¤–éƒ¨ä¼ å…¥çš„å‡½æ•°æˆ–å†…éƒ¨å®ç°
    const handleGenerateImage = externalHandleGenerateImage || internalHandleGenerateImage

    const [isBatchSubmittingAll, setIsBatchSubmittingAll] = useState(false)
    const [batchProgress, setBatchProgress] = useState({ current: 0, total: 0 })
    const [pendingRegenerationKeys, setPendingRegenerationKeys] = useState<Set<string>>(new Set())
    const [pendingRegenerationBaselines, setPendingRegenerationBaselines] = useState<Map<string, ManualRegenerationBaseline>>(new Map())

    // è·å–å½¢è±¡åˆ—è¡¨ï¼ˆå†…ç½®å®ç°ï¼Œä¸å†ä¾èµ–å¤–éƒ¨ä¼ å…¥ï¼‰
    const getAppearances = useCallback((character: Character): CharacterAppearance[] => {
        return character.appearances || []
    }, [])

    const activeTaskKeys = useMemo(() => {
        const generated = new Set<string>()

        for (const character of characters) {
            for (const appearance of character.appearances || []) {
                if (!isAppearanceTaskRunning(appearance)) continue
                const groupKey = `character-${character.id}-${appearance.appearanceIndex}-group`
                generated.add(groupKey)
                const imageCount = Math.max(1, appearance.imageUrls?.length || 0)
                for (let index = 0; index < imageCount; index += 1) {
                    generated.add(`character-${character.id}-${appearance.appearanceIndex}-${index}`)
                }
            }
        }

        for (const location of locations) {
            const hasRunningTask = !!location.images?.some((img) => img.imageTaskRunning)
            if (!hasRunningTask) continue
            generated.add(`location-${location.id}-group`)
            for (const image of location.images || []) {
                if (image.imageTaskRunning) {
                    generated.add(`location-${location.id}-${image.imageIndex}`)
                }
            }
        }

        for (const key of pendingRegenerationKeys) {
            generated.add(key)
        }

        return generated
    }, [characters, locations, pendingRegenerationKeys])

    useEffect(() => {
        if (pendingRegenerationKeys.size === 0) return

        const now = Date.now()
        setPendingRegenerationKeys((prev) => {
            let changed = false
            const next = new Set(prev)
            for (const key of prev) {
                if (shouldResolveManualKey(key, characters, locations, pendingRegenerationBaselines, now)) {
                    next.delete(key)
                    changed = true
                }
            }
            return changed ? next : prev
        })
        setPendingRegenerationBaselines((prev) => {
            if (prev.size === 0) return prev
            let changed = false
            const next = new Map(prev)
            for (const key of Array.from(next.keys())) {
                if (!pendingRegenerationKeys.has(key)) {
                    next.delete(key)
                    changed = true
                    continue
                }
                if (shouldResolveManualKey(key, characters, locations, prev, now)) {
                    next.delete(key)
                    changed = true
                }
            }
            return changed ? next : prev
        })
    }, [characters, locations, pendingRegenerationBaselines, pendingRegenerationKeys])

    // ç”Ÿæˆå…¨éƒ¨èµ„äº§å›¾ç‰‡ï¼ˆä»…ç¼ºå¤±å›¾ç‰‡çš„ï¼‰
    const handleGenerateAllImages = async () => {
        const tasks: Array<{
            type: 'character' | 'location'
            id: string
            appearanceId?: string
            appearanceIndex?: number
            key: string
        }> = []

        // æ”¶é›†è§’è‰²èµ„äº§
        characters.forEach(char => {
            const appearances = getAppearances(char)
            appearances.forEach(app => {
                if (!app.imageUrl && !app.imageUrls?.length) {
                    tasks.push({
                        type: 'character',
                        id: char.id,
                        appearanceId: app.id,
                        appearanceIndex: app.appearanceIndex,
                        key: `character-${char.id}-${app.appearanceIndex}-group`
                    })
                }
            })
        })

        // æ”¶é›†åœºæ™¯èµ„äº§
        locations.forEach(loc => {
            const hasImage = loc.images?.some(img => img.imageUrl)
            if (!hasImage) {
                tasks.push({
                    type: 'location',
                    id: loc.id,
                    key: `location-${loc.id}-group`
                })
            }
        })

        if (tasks.length === 0) {
            alert(t('toolbar.generateAllNoop'))
            return
        }

        setIsBatchSubmittingAll(true)
        setBatchProgress({ current: 0, total: tasks.length })

        const allKeys = new Set(tasks.map(t => t.key))
        setPendingRegenerationKeys(prev => new Set([...prev, ...allKeys]))
        setPendingRegenerationBaselines(prev => {
            const next = new Map(prev)
            for (const key of allKeys) {
                const baseline = createManualKeyBaseline(key, characters, locations)
                if (baseline) {
                    next.set(key, baseline)
                }
            }
            return next
        })

        try {
            await Promise.all(
                tasks.map(async (task) => {
                    let submitted = false
                    try {
                        await handleGenerateImage(task.type, task.id, task.appearanceId, false)
                        submitted = true
                        setBatchProgress(prev => ({ ...prev, current: prev.current + 1 }))
                    } catch (error) {
                        _ulogError(`Failed to generate ${task.type} ${task.id}:`, error)
                        setBatchProgress(prev => ({ ...prev, current: prev.current + 1 }))
                    } finally {
                        if (!submitted) {
                            setPendingRegenerationKeys(prev => {
                                const next = new Set(prev)
                                next.delete(task.key)
                                return next
                            })
                            setPendingRegenerationBaselines(prev => {
                                if (!prev.has(task.key)) return prev
                                const next = new Map(prev)
                                next.delete(task.key)
                                return next
                            })
                        }
                    }
                })
            )
        } finally {
            setIsBatchSubmittingAll(false)
            setBatchProgress({ current: 0, total: 0 })
            refreshAssets()
        }
    }

    // é‡æ–°ç”Ÿæˆå…¨éƒ¨èµ„äº§å›¾ç‰‡ï¼ˆåŒ…å«å·²æœ‰å›¾ç‰‡çš„ï¼‰
    const handleRegenerateAllImages = async () => {
        if (!confirm(t('toolbar.regenerateAllConfirm'))) return

        const tasks: Array<{
            type: 'character' | 'location'
            id: string
            appearanceId?: string
            appearanceIndex?: number
            key: string
        }> = []

        characters.forEach(char => {
            const appearances = getAppearances(char)
            appearances.forEach(app => {
                tasks.push({
                    type: 'character',
                    id: char.id,
                    appearanceId: app.id,
                    appearanceIndex: app.appearanceIndex,
                    key: `character-${char.id}-${app.appearanceIndex}-group`
                })
            })
        })

        locations.forEach(loc => {
            tasks.push({
                type: 'location',
                id: loc.id,
                key: `location-${loc.id}-group`
            })
        })

        if (tasks.length === 0) {
            alert(t('toolbar.noAssetsToGenerate'))
            return
        }

        setIsBatchSubmittingAll(true)
        setBatchProgress({ current: 0, total: tasks.length })

        const allKeys = new Set(tasks.map(t => t.key))
        setPendingRegenerationKeys(prev => new Set([...prev, ...allKeys]))
        setPendingRegenerationBaselines(prev => {
            const next = new Map(prev)
            for (const key of allKeys) {
                const baseline = createManualKeyBaseline(key, characters, locations)
                if (baseline) {
                    next.set(key, baseline)
                }
            }
            return next
        })

        try {
            await Promise.all(
                tasks.map(async (task) => {
                    let submitted = false
                    try {
                        await handleGenerateImage(task.type, task.id, task.appearanceId, false)
                        submitted = true
                        setBatchProgress(prev => ({ ...prev, current: prev.current + 1 }))
                    } catch (error) {
                        _ulogError(`Failed to generate ${task.type} ${task.id}:`, error)
                        setBatchProgress(prev => ({ ...prev, current: prev.current + 1 }))
                    } finally {
                        if (!submitted) {
                            setPendingRegenerationKeys(prev => {
                                const next = new Set(prev)
                                next.delete(task.key)
                                return next
                            })
                            setPendingRegenerationBaselines(prev => {
                                if (!prev.has(task.key)) return prev
                                const next = new Map(prev)
                                next.delete(task.key)
                                return next
                            })
                        }
                    }
                })
            )
        } finally {
            setIsBatchSubmittingAll(false)
            setBatchProgress({ current: 0, total: 0 })
            refreshAssets()
        }
    }

    // æ¸…é™¤å•ä¸ªæœ¬åœ°å…œåº•çŠ¶æ€ï¼ˆä»…ç”¨äºæäº¤å¤±è´¥åœºæ™¯ï¼‰
    const clearTransientTaskKey = useCallback((key: string) => {
        setPendingRegenerationKeys(prev => {
            const next = new Set(prev)
            next.delete(key)
            return next
        })
        setPendingRegenerationBaselines(prev => {
            if (!prev.has(key)) return prev
            const next = new Map(prev)
            next.delete(key)
            return next
        })
    }, [])

    return {
        // ğŸ”¥ æš´éœ²æ•°æ®ä¾›ç»„ä»¶ä½¿ç”¨
        characters,
        locations,
        getAppearances,
        // çŠ¶æ€
        isBatchSubmitting: isBatchSubmittingAll,
        batchProgress,
        activeTaskKeys,
        setTransientRegenerationKeys: setPendingRegenerationKeys,
        clearTransientTaskKey,
        // æ“ä½œ
        handleGenerateAllImages,
        handleRegenerateAllImages
    }
}
